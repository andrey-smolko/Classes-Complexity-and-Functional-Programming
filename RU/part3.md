# Пути избавления от `this`

Итак, если `this` добавляет столько сложности (как я полагаю), как же нам избавиться от него, при этом не добавив еще больше сложности в код? Как насчет того чтобы вместо классического объектно-ориентированного подхода , мы попробуем более функциональный подход? Вот что получится, если мы будем использовать [чистые функции](https://en.wikipedia.org/wiki/Pure_function):

```js
function setName(person, strName) {
  return Object.assign({}, person, {name: strName})
}

// Бонусная функция!
function setGreeting(person, newGreeting) {
  return Object.assign({}, person, {greeting: newGreeting})
}

function getName(person) {
  return getPrefixedName('Name', person.name)
}

function getPrefixedName(prefix, name) {
  return `${prefix}: ${name}`
}

function getGreetingCallback(person) {
  const {greeting, name} = person
  return (subject) => `${greeting} ${subject}, I'm ${name}`
}

const person = {greeting: 'Hey there!', name: 'Jane Doe'}
const person2 = setName(person, 'Sarah Doe')
const person3 = setGreeting(person2, 'Hello')
getName(person3) // Name: Sarah Doe
getGreetingCallback(person3)('Jeff') // Hello Jeff, I'm Sarah Doe
```

В этом случае у нас нет никакой связи с `this`. Нам не надо думать об этом. И, как результат, это намного легче понять. Только функции и объекты. Нет, практически, ничего дополнительного, что вам необходимо держать в голове. `person` это всего лишь объект с данными. Вот что показывает консоль в Chrome:

![pic1](https://cdn-images-1.medium.com/max/800/1*dWZiYJoerNxSseHZ_XfKPA.png)

В функциональном программирования есть еще один приятный бонус, в который мы не будем сильно вдаваться - эти функции очень легко тестировать. Вы просто вызываете функцию с неким набором параметров и сравниваете с выходным значение. На мой взгляд, это очень приятный бонус!

Функциональное программирование более сосредоточенно на том, чтобы сделать код проще в понимании. Но это только до тех пор, пока ваш код "достаточно быстр". Вопреки скорости исполнения, в некоторых ситуациях мы *можем* получить некоторые другие оптимизации (например надежное использование `===` для сравнивания объектов). В большинстве случаев, **ваше использование функционального программирования** *будет в конце списка узких мест, которые замедляют ваше приложение.*

## Недостатки и Преимущества

Использование `class` - это не плохо. У него действительно есть свое место. Если у вас есть [Хот-спот](https://ru.wikipedia.org/wiki/%D0%A5%D0%BE%D1%82-%D1%81%D0%BF%D0%BE%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) который является узким местом вашего приложения, тогда использования `class` может реально повысить производительность. Но в 99% случаях, дело не в этом. И я не вижу, как `классы` и сложность использования `this` стоят потраченных усилий на написание и поддержку кода (и мы даже не начинали говорить [прототипном наследовании](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)). У меня не было такого опыта в разработке, когда мне действительно были нужны `классы` для оптимизации производительности. Так что я использую их только для компонентов React, потому что это единственное что нам остается, если мы хотим использовать state и lifecycle методы (но возможно в [скором времени это изменится](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State)).

## Заключение

У классов (и прототипов) есть свое место в Javascript. Но оно, как правило, касается оптимизации. Они не делают ваш код проще, а наоборот усложняют. Лучше всего сфокусироваться на вещах, которые не только проще в изучении, но и проще в понимании: функции и объекты.